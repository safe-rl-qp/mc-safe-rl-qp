{% include h3.html title="なぜ複数のロボットを使用するのか" %}

<p>このセクションでは、1台のロボットだけでなく複数のロボットを同時に制御します。この手法を使用すると、数多くの自由度を制御する際に計算負荷が非常に高くなりますが、以下のことが可能となります。</p>

<ul>
  <li>ロボット間の制約条件（接触面や衝突メッシュなど）を指定する</li>
  <li>連携してタスクを実行する</li>
  <li>多関節オブジェクトを操作する</li>
</ul>

<p>これらすべてを、インバースキネマティクスを明示的に行わずに実現できます。</p>

<p>これを実現するため、本フレームワークの二次計画法コントローラーは、一定の制約条件の下で、ロボットのシステム全体が考慮された目的関数の値を最小にします。</p>

<p>今回の例では、自由度2のシンプルなオブジェクト（ドア）の操作について見ていきます。ここでは、ドアのハンドルに向けてロボットの手を伸ばし、ハンドルを回してドアを開くという動作を実現します。</p>

<p><em>注: この記事では、読者がROSを使用してコントローラを実行・可視化できることを前提として説明します。</em></p>


{% include h3.html title="例" %}

<p>ここでは、JVRC1とドアを読み込むシンプルなコントローラーを構築します。このドアは、既にインストールされている{% link mc_rtc_data %}パッケージに含まれています。</p>

<p>では、複数のロボットを入力として受け取るコントローラーを構築しましょう。</p>

<ul>
  <li>JVRC1</li>
  <li>ドア</li>
  <li>地面</li>
</ul>

<p>これを実現するには、コンストラクターを以下のように編集します。</p>

{% include show_sources.html sources=page.constructor_sources copy=false id="constructor" %}

{% include h4.html title="ロボットのインデックス" %}

<p>今回の新しい例では、追加のロボット（ドア）を読み込みました。その際、読み込むべきロボットモジュールのリストを指定しました。読み込まれたロボットには、モジュールを指定した順にインデックスが付けられています。すなわち、メインロボットのインデックスは0のままですが、ドアにはインデックス1が、地面にはインデックス2が付けられています。そのため、接触面の設定を以下のように変更する必要があります。</p>

{% include show_sources.html sources=page.set_contact_sources copy=false id="set_contact" %}

{% include h4.html title="ドアの初期位置" %}

<p>この状態でコントローラーを起動すると、ドアとロボットが同じ場所に表示されるのが分かります。今回のチュートリアルの目的を達成するには、ドアの位置を手動で変更する必要があります。</p>

{% include show_sources.html sources=page.reposition_door_sources copy=false id="reposition_door" %}

{% include h4.html title="ドアのタスクと制約条件" %}

<p>新しい多関節ロボットを追加したため、このロボットにいくつかの制約条件を追加する必要があります。今回は、キネマティクス制約条件と姿勢制御タスクのみを追加します。</p>

{% include show_sources.html sources=page.add_door_tasks_sources copy=false id="add_door_tasks" %}

<p><em>注: ドアは土台が固定されているため、この段階ではドアに接触面を追加しません。ただし、コントローラーに読み込まれているすべてのロボットに対して接触面制約条件を直接適用できます。</em>

{% include h4.html title="コントローラーのロジックを定義する" %}

<p>ここでは、コントローラーのロジックを以下のように定義します。</p>

<ol>
  <li>ドアのハンドルに向けてロボットの手を伸ばす</li>
  <li>ドアのハンドルを回す</li>
  <li>ドアを開く</li>
</ol>

<p>これらを反映したコードは以下のようになります。</p>

{% include show_sources.html sources=page.logic_setup_sources copy=false id="logic_setup" %}

{% include h4.html title="フェーズ1: ハンドルに手を伸ばす" %}

<p>このフェーズでは、<code>SurfaceTransformTask</code>を導入します。これは、以前に使用した<code>EndEffectorTask</code>と非常によく似ていますが、このタスクはエンドエフェクターではなくロボットの表面を制御します。このタスクでは通常、目標を表すのが簡単になります。さらに、ドアの位置を動かしたり手を変更したりする際にコードを編集しなくて済むように、ドアのハンドルの位置を用いて目標を定義します。</p>

{% include show_sources.html sources=page.p1_sources copy=false id="p1" %}

{% include h4.html title="フェーズ2: ハンドルを動かす" %}

<p>Wフェーズ2では以下の2つの項目を設定します。</p>

<ol>
 <li>フェーズ2をいつトリガーするか</li>
  <li>何を実行するか</li>
</ol>

<p>最初の項目については、<code>SurfaceTransformTask</code>の実行を監視します。2番目の項目については、ドアとロボットのグリッパーとの間に接触面を追加し、ロボットのグリッパーに関するタスクを削除し（これは現在、接触面によって処理されています）、ハンドルの位置に関する目標を変更します。</p>

{% include show_sources.html sources=page.p2_sources copy=false id="p2" %}

{% include h4.html title="フェーズ3: ドアを開く" %}

<p>このフェーズは、前のフェーズと非常によく似ています。ロボットの手が接触して遷移が引き起こされたハンドルの位置をチェックし、ドアを開く動作に関する目標を設定します。</p>

{% include show_sources.html sources=page.p3_sources copy=false id="p3" %}

{% include h3.html title="いろいろ試してみよう" %}

<p>ここで、いくつかのパラメーターをいろいろと変更し、マルチロボットのアプローチのメリットを確認してみましょう。他のパラメーターは変更せずに、以下の項目を試してみてください。</p>

<ul>
 <li>ドアの位置を変更する</li>
  <li>ドアのハンドルを回す角度を変更する</li>
  <li>ドアを開く角度を変更する</li>
  <li>ドアを開くのに使用するロボットの手を変更する</li>
</ul>

<p><em>注: 当然ながら、設定したとおりに実行できない場合もあります。例えば、ロボットから10m離れた場所にドアを置けば、ドアのハンドルにロボットの手が届かなくなります。</em></p>

{% include h3.html title="有限オートマトン機能の紹介" %}

<p>このチュートリアルでは、mc_rtcのコントローラーについて紹介しました。次のチュートリアルでは、本フレームワークで用意されている高度なツールを使用して複雑なコントローラーのプログラミングとデバッグの仕方について説明します。これまでの説明では、非常に初歩的な方法でコントローラーのロジックをプログラミングしてきました。本フレームワークでは、<a href="{{site.baseurl}}/tutorials/recipes/fsm.html">有限オートマトン機能を紹介するチュートリアル</a>や <a href="{{site.baseurl}}/tutorials/recipes/fsm-example.html">実用的な有限オートマトンのチュートリアル</a>で紹介されているようなシナリオを扱うための、大変強力な手段が用意されています。後者のチュートリアルでは、有限オートマトン機能を使って、今回のチュートリアルと同じ内容をプログラミングします。</p>

<p>このコントローラーの完全なソースは、<a href="sources/multi-robot-controller.html">こちら</a>から入手できます。</p>
